<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Sketchbook Flip - Custom Model</title>
  <style>
    body {
      margin: 0;
      background: #dcd3c3;
      overflow: hidden;
      font-family: 'Georgia', serif;
    }
    canvas {
      display: block;
      touch-action: none;
    }
    #instructions {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      text-align: center;
      z-index: 10;
    }
    #instructions h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      color: #333;
    }
    #instructions p {
      margin: 4px 0;
      font-size: 13px;
      color: #666;
    }
    #modelInput {
      position: absolute;
      top: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10;
      max-width: 400px;
    }
    #modelInput input {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border: 2px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }
    #modelInput button {
      width: 100%;
      padding: 10px;
      background: #8b4513;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 10px;
    }
    #modelInput button:hover {
      background: #6d3410;
    }
    #modelInput label {
      display: block;
      margin-top: 10px;
      font-size: 13px;
      color: #666;
    }
    .file-input {
      display: none;
    }
    .file-button {
      background: #4a7c59 !important;
    }
    .file-button:hover {
      background: #3a5f45 !important;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 8px;
      display: none;
      z-index: 20;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h3>Interactive Sketchbook</h3>
    <p>Click to flip forward • Right-click to flip back</p>
    <p>Drag to rotate • Scroll to zoom</p>
  </div>

  <div id="modelInput">
    <h3 style="margin-top: 0;">Load Your Model</h3>
    <label>Upload GLB/GLTF file:</label>
    <input type="file" id="fileInput" class="file-input" accept=".glb,.gltf" />
    <button class="file-button" onclick="document.getElementById('fileInput').click()">Choose File</button>
    <p style="margin: 15px 0; text-align: center;">— OR —</p>
    <label>Enter model URL:</label>
    <input type="text" id="urlInput" placeholder="https://example.com/sketchbook.glb" />
    <button onclick="loadFromURL()">Load from URL</button>
    <p style="margin-top: 15px; font-size: 12px; color: #999;">
      Tip: Name your pages "Page1", "Page2", etc. in Nomad Sculpt
    </p>
  </div>

  <div id="loading">
    <p>Loading model...</p>
  </div>

  <canvas id="scene"></canvas>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, book, pages = [], currentPage = 0;
    let isDragging = false, prevMouse = { x: 0, y: 0 };
    let bookRotation = { x: -0.3, y: 0 };
    let isAnimating = false;
    let GLTFLoader;

    init();
    loadGLTFLoader();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('scene'), 
        antialias: true 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xdcd3c3);
      renderer.shadowMap.enabled = true;

      const light = new THREE.DirectionalLight(0xfff5e6, 1);
      light.position.set(4, 6, 3);
      light.castShadow = true;
      scene.add(light);

      const ambient = new THREE.AmbientLight(0xfff8f0, 0.7);
      scene.add(ambient);

      const fillLight = new THREE.DirectionalLight(0xe6f3ff, 0.3);
      fillLight.position.set(-3, 2, -2);
      scene.add(fillLight);

      camera.position.set(0, 2, 5);
      camera.lookAt(0, 0, 0);

      window.addEventListener('resize', onWindowResize);
      window.addEventListener('mousedown', onMouseDown);
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);
      window.addEventListener('wheel', onWheel);
      window.addEventListener('contextmenu', e => e.preventDefault());
      
      document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    }

    function loadGLTFLoader() {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
      script.onload = () => {
        GLTFLoader = THREE.GLTFLoader;
      };
      document.head.appendChild(script);
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      document.getElementById('loading').style.display = 'block';
      const url = URL.createObjectURL(file);
      loadModel(url);
    }

    function loadFromURL() {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) {
        alert('Please enter a valid URL');
        return;
      }
      document.getElementById('loading').style.display = 'block';
      loadModel(url);
    }

    function loadModel(url) {
      if (!GLTFLoader) {
        setTimeout(() => loadModel(url), 100);
        return;
      }

      const loader = new GLTFLoader();
      loader.load(
        url,
        (gltf) => {
          document.getElementById('modelInput').style.display = 'none';
          document.getElementById('loading').style.display = 'none';
          
          if (book) {
            scene.remove(book);
          }
          
          book = gltf.scene;
          scene.add(book);
          
          // Find pages - look for objects with "Page" or "page" in name
          pages = [];
          book.traverse((child) => {
            if (child.isMesh && child.name.toLowerCase().includes('page')) {
              const pageGroup = new THREE.Group();
              pageGroup.add(child.clone());
              pageGroup.position.copy(child.position);
              pageGroup.rotation.copy(child.rotation);
              
              pageGroup.userData.flipped = false;
              pageGroup.userData.targetRotation = 0;
              pageGroup.userData.currentRotation = 0;
              pageGroup.userData.originalParent = child.parent;
              
              pages.push(pageGroup);
              
              child.visible = false;
            }
          });
          
          // Sort pages by name
          pages.sort((a, b) => {
            const numA = parseInt(a.children[0].name.match(/\d+/) || 0);
            const numB = parseInt(b.children[0].name.match(/\d+/) || 0);
            return numA - numB;
          });
          
          // Add sorted pages to scene
          pages.forEach(pageGroup => {
            book.add(pageGroup);
          });
          
          // Center and scale the model
          const box = new THREE.Box3().setFromObject(book);
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          
          book.position.sub(center);
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 3 / maxDim;
          book.scale.setScalar(scale);
          
          book.rotation.x = bookRotation.x;
          book.rotation.y = bookRotation.y;
          
          currentPage = 0;
          
          console.log(`Loaded ${pages.length} pages:`, pages.map(p => p.children[0].name));
        },
        (progress) => {
          console.log(`Loading: ${(progress.loaded / progress.total * 100).toFixed(0)}%`);
        },
        (error) => {
          document.getElementById('loading').style.display = 'none';
          alert('Error loading model. Make sure the URL is correct and CORS is enabled.');
          console.error('Load error:', error);
        }
      );
    }

    function flipPage(forward = true) {
      if (isAnimating || pages.length === 0) return;
      
      if (forward && currentPage < pages.length) {
        isAnimating = true;
        const page = pages[currentPage];
        page.userData.targetRotation = page.userData.currentRotation - Math.PI;
        page.userData.flipped = true;
        currentPage++;
      } else if (!forward && currentPage > 0) {
        isAnimating = true;
        currentPage--;
        const page = pages[currentPage];
        page.userData.targetRotation = page.userData.currentRotation + Math.PI;
        page.userData.flipped = false;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      
      let allDone = true;
      pages.forEach(page => {
        const diff = page.userData.targetRotation - page.userData.currentRotation;
        if (Math.abs(diff) > 0.01) {
          page.userData.currentRotation += diff * 0.15;
          page.rotation.y = page.userData.currentRotation;
          allDone = false;
        } else {
          page.userData.currentRotation = page.userData.targetRotation;
          page.rotation.y = page.userData.currentRotation;
        }
      });
      
      if (allDone) isAnimating = false;
      
      if (book) {
        book.rotation.x = bookRotation.x;
        book.rotation.y = bookRotation.y;
      }
      
      renderer.render(scene, camera);
    }

    function onMouseDown(e) {
      if (e.button === 0) {
        if (!isDragging) flipPage(true);
      } else if (e.button === 2) {
        flipPage(false);
      }
      isDragging = true;
      prevMouse = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
      if (!isDragging) return;
      
      const deltaX = e.clientX - prevMouse.x;
      const deltaY = e.clientY - prevMouse.y;
      
      if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
        bookRotation.y += deltaX * 0.01;
        bookRotation.x += deltaY * 0.01;
        bookRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, bookRotation.x));
      }
      
      prevMouse = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onWheel(e) {
      camera.position.z += e.deltaY * 0.01;
      camera.position.z = Math.max(2, Math.min(15, camera.position.z));
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
